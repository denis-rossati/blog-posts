# Vibe coders, you are already outdated.

"_What if we added a dumbass that is constantly wrong to every product?_" — tech bro, probably.

Today I was mocking around with friends at work. It was a good 30 mins of discussing something totally random. Some weeks ago, we asked ourselves "why is 4 in roman numerals IV and not IIII? And why is 4 in japanese represented by a weird square instead of four dashes?". Those are interesting questions, look it up.

Today's subject was vibe coding, and we found a conclusion that this has been a thing since the beginning of software engineering. Vibe coding is just extreme go horse. **BUT. ON. STEROIDS**.

Before you proceed, this **is** a rant, this **is** me taking something off my chest, this **IS** a text with UNNECESSARY uppercase and bold words.

I believe that vibe coding is just a big joke that's going over my head.

Also, this little writing is inspired by "[Doing Dumb Stuff Faster Is Still Dumb](https://anniemueller.com/posts/doing-dumb-stuff-faster-is-still-dumb)" by Annie Mueller — check it out if you want to read a pocket version of this post.

---

We need to recognize something, too. Vibe coding, as described in [this podcasty... eh... thing](https://www.youtube.com/watch?v=IACHfKmZMr8) is a technique to ship products as quickly as possible. I can see that clearly. But is anyone questioning the consequences here?

Be real: you won't stop "vibe coding" after releasing the MVP; this is now rooted in your culture deck. In the video, those guys said that this is the situation when you're going to need real engineers. Be prepared to spend a salty sum to convince someone to fix the mess you created, and keep in mind that this individual will have high bargaining power. Or do you think you're the only early-stage company with unmaintainable code?

Early stage companies are well known for their spaghetti code due to the fast pace in the initial stages, which is understandable. Add that to the massive amounts of trash-generated code — can you comprehend the incoming technical debt here? Your client want features, he probably won't be waiting for you to rewrite your MVP

---

I'll start by saying that "vibe coding" is a terrible name, and I won't even elaborate further. Freaking "**extreme go horse**" is much cooler.

In my opinion, not all extreme go horse axioms are being fulfilled, because some of them aren't code axioms, but people axioms. With that said, I'll only summarize the axioms that we can easily find in vibe coding.

### I think, therefore it’s not XGH

Thinking is not necessary to see how this is related to vibe coding either. You just say what you want and let the AI do the heavy lifting. What could go wrong?

### There are three ways of solving a problem: the right way, the wrong way, and the XGH way — which is exactly like the wrong one, but faster.

This is my favorite so far. Is something wrong? Just ask AI to rewrite that crap until it gets it right, or you end up broke, or you get a 429 error in your face! It's faster than any development process you know anyway.

Also, I can only picture this:

![I'm stupid faster](https://cdn.denis.my/assets/stupid-faster.png)

### You’ll always need to do more and more XGH.

["6 months ago I was a 10x faster, now I'm a 100x faster"](https://youtu.be/IACHfKmZMr8?t=156)

This goes back to "are you delusional enough to believe you are going to stop vibe coding when you release your first version?"

I don't like to be pessimistic, but I'm sure I'll encounter 100x more vulnerabilities.

Don't worry, though. Vibe coding requires you to just throw in the error and let the AI do the rest. Remember that your brain must be soap-like: no wrinkles at all!

Also, the vulnerabilities I just mentioned will be solved 1000x faster, right?

### XGH is completely reactive.

As expected, vibe coding is reactive. You just feed your code into AI without analyzing it; you'll only see bugs when they happen — otherwise, they don't exist. In fact, don't even think about adding observability to your application. Better yet, DON'T THINK AT ALL.

### In XGH anything goes.

![All wrong](https://cdn.denis.my/assets/all-wrong.jpg)

Of course, everything goes ~wrong~

### You always commit before updating.

You don't need to uh... test things. Your codebase now is a black box, after all, there is no such thing as garbage-in, garbage-out. If it works, it works. Deploy it.

### XGH doesn’t have schedules.

"_client schedules are all but important_"

That is because you can deliver everything on time with AI!!! [Check this _advanced_ vibe code technique](https://youtu.be/IACHfKmZMr8?t=140). And as the guy said shortly after, why not 3 screens with AI? Heck, why not 5? Totally healthy workplace!

### There’s no refactoring — just rework.

[EMBRACE THE VIBES](https://youtu.be/IACHfKmZMr8?t=308). If you have a huge fucking system, you just ask it to rewrite the whole thing, right? In fact, rewrite it in Rust, that I'll solve our latency issues as well!

If you have the guts to watch the whole talk, I'll see that this subject appears often, and it seems that they don't take in account that some features are simply HUGE.

### XGH is anarchic.

So is any code made by AI. Remember that "_in XGH anything goes_".

### "XGH is absolute"

See the axiom below.

### "XGH is not a fad"

[He said the same freaking phrase](https://youtu.be/IACHfKmZMr8?t=8). This is one of the reasons I think this is a huge joke that I didn't get it.

At this point, XGH and vibe coding are synonymous to me.

### XGH is not always WOP (workaround oriented programming).

We saw this earlier: workarounds require thinking and some refactoring. Sorry, man. You'll have to prompt AI to do everything again.

### Don’t try to go against the tide.

This one is for the competent engineers. Everybody is just viiiibing. Why are you worrying about testable and maintainable code? For every well-thought-out line you add, there are five AI agents throwing garbage at the fan. Just quit it! You are ruining the vibe.

### XGH is not dangerous until you see some order in it.

Maybe this one shouldn't be here; after all, your codebase is now a black box, so you don't _need_ see a thing.

---

I'll close with two of Brian Kernighan's phrases, dating back to the '70s and still relevant:

_Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it._

_Controlling complexity is the essence of computer programming._

Y'all know what I'm trying to say here.

---

Okay, so final countdown: vibe coding checks 14 out of 22 axioms. We still need to accomplish:

- Be ready to jump ship or blame someone else when it goes down.
- Be authentic. XGH doesn’t follow patterns.
- Always believe in improvement promises.
- XGH is your bro. But it’s vengeful.
- If it's working, don't bother.
- Tests are for pussies.
- Be used to the "living on the edge" feeling.
- The problem is only yours when your name is on the code docs.

We are almost there. In truth, some of them are very tied to vibe coding; I'm just too lazy to write more stuff right now. Maybe I should assign an AI to write it for me.

Apart from that, even though millions of dollars and wasted energy have been injected into AI, I can still breathe fresh air. C'mon, Silicon Valley guys!!

---

To be fair, [I have to give credit to the most honest sentence in the whole video right here, with a slight correction](https://youtu.be/IACHfKmZMr8?t=1025): vibe coding (formally extreme go horse) MIGHT be SOMEWHAT useful to get from 0 to 1. If it's not, just hire someone or learn to code, goddamn it. Beyond that, I wouldn't rely on it.

Additionally, [they said that reading and spotting bad code is a relevant skill for vibe coding](https://youtu.be/IACHfKmZMr8?t=1303). But let's be real: they are trying really hard to automate code. Don't get me wrong — it's interesting to see the crazy stuff that is coming out of it, but AI isn't really the sharpest tool in the shed right now.

Besides that, the amount of money injected into "vibe coding" makes me fear that this is becoming a real thing, with projects that put lives at risk being powered by such potentially fragile code.

I think this concept will fall over very soon.

I hope.
